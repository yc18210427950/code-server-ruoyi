{
  "manifest": {
    "name": "omelette",
    "description": "Omelette.js Simple Autocompletion Helper for Node",
    "keywords": [
      "autocompletion",
      "complete",
      "bash completion",
      "zsh completion"
    ],
    "author": {
      "name": "Fatih Kadir Akƒ±n",
      "email": "fka@fatihak.in"
    },
    "version": "0.4.5",
    "licenses": [
      {
        "type": "MIT"
      }
    ],
    "engines": {
      "node": ">=0.8.0"
    },
    "main": "./src/omelette.js",
    "homepage": "https://github.com/f/omelette",
    "bugs": {
      "url": "https://github.com/f/omelette/issues"
    },
    "repository": {
      "type": "git",
      "url": "git://github.com/f/omelette.git"
    },
    "_registry": "npm",
    "_loc": "/config/.cache/yarn/v6/npm-omelette-0.4.5-f16bc477b7e263b59796a65661964e4762e9ae74-integrity/node_modules/omelette/package.json",
    "readmeFilename": "README.md",
    "readme": "<img src=\"https://rawgit.com/f/omelette/master/resources/logo.svg?v1\" height=\"80\">\n\n> Omelette is a simple, template based autocompletion tool for Node projects with super easy API.\n\n[![npm version](https://badge.fury.io/js/omelette.svg)](https://badge.fury.io/js/omelette)\n[![Build Status](https://travis-ci.org/f/omelette.svg?branch=master)](https://travis-ci.org/f/omelette)\n\n```bash\nyarn add omelette\n# or\nnpm install omelette\n```\n\nYou just have to decide your program name and CLI fragments.\n\n```javascript\nomelette`github ${['pull', 'push']} ${['origin', 'upstream']} ${['master', 'develop']}`.init()\n```\n\nAnd you are almost done! The output will be like this:\n\n<img src=\"https://raw.github.com/f/omelette/master/resources/omelette-new.gif?v1\" width=\"640\">\n\n## Quick Start\n\nImplementing omelette is very easy.\n\n```javascript\nimport * as omelette from 'omelette';\n\nconst firstArgument = ({ reply }) => {\n  reply([ 'beautiful', 'cruel', 'far' ])\n}\n\nconst planet = ({ reply }) => {\n  reply([ 'world', 'mars', 'pluto' ])\n}\n\nomelette`hello|hi ${firstArgument} ${planet}`.init()\n```\n\n<img src=\"https://raw.github.com/f/omelette/master/resources/omelette-new-hello.gif?v1\" width=\"640\">\n\n### Simple Event Based API ‚òïÔ∏è\n\nIt's based on a simple CLI template.\n\nLet's think we have a executable file with the name **githubber**, *in a global path*.\n\nAnd in our program, code will be:\n\n```javascript\nimport * as omelette from 'omelette';\n\n// Write your CLI template.\nconst completion = omelette(`githubber|gh <action> <user> <repo>`);\n\n// Bind events for every template part.\ncompletion.on('action', ({ reply }) => {\n  reply([ 'clone', 'update', 'push' ])\n})\n\ncompletion.on('user', ({ reply }) => {\n  reply(fs.readdirSync('/Users/'))\n})\n\ncompletion.on('repo', ({ before, reply }) => {\n  reply([\n    `http://github.com/${before}/helloworld`,\n    `http://github.com/${before}/blabla`\n  ])\n})\n\n// Initialize the omelette.\ncompletion.init()\n\n// If you want to have a setup feature, you can use `omeletteInstance.setupShellInitFile()` function.\nif (~process.argv.indexOf('--setup')) {\n  completion.setupShellInitFile()\n}\n\n// Rest is yours\nconsole.log(\"Your program's default workflow.\")\nconsole.log(process.argv)\n```\n\n`complete.reply` is the completion replier. You must pass the options into that method.\n\n### ES6 Template Literal API üöÄ\n\nYou can use **Template Literals** to define your completion with a simpler (super easy) API.\n\n```javascript\nimport * as omelette from 'omelette';\n\n// Just pass a template literal to use super easy API.\nomelette`hello ${[ 'cruel', 'nice' ]} ${[ 'world', 'mars' ]}`.init()\n```\n\nLet's make the example above with ES6 TL:\n\n```javascript\nimport * as omelette from 'omelette'\n\n// Write your CLI template.\nomelette`\n  githubber|gh\n  \n  ${[ 'clone', 'update', 'push' ]}\n  ${() => fs.readdirSync('/Users/')} \n  ${({ before }) => [\n    `http://github.com/${before}/helloworld`,\n    `http://github.com/${before}/blabla`,\n  ]}\n`.init()\n```\n\nAlso you can still use lambda functions to make more complex template literals:\n\n#### Advanced Template Literals\n\n```javascript\nimport * as omelette from 'omelette';\n\nomelette`\n  githubber|gh\n      ${['pull', 'push', 'star'] /* Direct command list */}\n      ${require('some/other/commands') /* Import from another file */}\n      ${getFromRemote('http://api.example.com/commands') /* Remote call at the beginning */}\n      ${({ reply }) => fetch('http://api.example.com/lazy-commands').then(reply) /* Fetch when argument <tab>bed */}\n      ${() => fs.readdirSync(\"/Users/\") /* Access filesystem via Node */}\n      ${({ before }) => [ /* Use parameters like `before`, `line`, `fragment` or `reply` */\n        `${before}/helloworld`,\n        `${before}/blabla`\n      ]}\n  `.init()\n\n// No extra configuration required.\n\nconsole.log(\"Your program's default workflow.\")\nconsole.log(process.argv)\n```\n\n### Tree API üå≤\n\nYou can use `simple objects` as autocompletion definitions:\n\n```javascript\nomelette('hello').tree({\n  cruel: ['world', 'moon'],\n  beautiful: ['mars', 'pluto']\n}).init();\n```\n\n## Install\n\n### Automated Install\n\nInstalling, and making your users install the autocompletion feature is very simple.\n\nYou can use simply use `setupShellInitFile` function.\n\n```javascript\n// If you want to write file,\ncomplete.setupShellInitFile('~/.my_bash_profile')\n```\n\nIf you use Bash, it will create a file at `~/.<program-name>/completion.sh` and\nappend a loader code to `~/.bash_profile` file.\n\nIf you use Zsh, it appends a loader code to `~/.zshrc` file.\n\nIf you use Fish, it appends a loader code to `~/.config/fish/config.fish` file.\n\n*TL;DR: It does the Manual Install part, basically.*\n\n### Manual Install\n\n*(You should add these instructions to your project's README)*\n\nIn **zsh**, you can write these:\n\n```bash\necho '. <(./githubber --completion)' >> .zshrc\n```\n\nIn **bash**, you should write:\n\n```bash\n./githubber --completion >> ~/githubber.completion.sh\necho 'source ~/githubber.completion.sh' >> .bash_profile\n```\n\nIn **fish**, you can write:\n\n```bash\necho 'githubber --completion-fish | source' >> ~/.config/fish/config.fish\n```\n\nThat's all!\n\nNow you have an autocompletion system for your CLI tool.\n\n## Additions\n\nThere are some useful additions for omelette.\n\n\n### Parameters\n\nCallbacks have two parameters:\n\n  - The fragment name (e.g.`command` of `<command>` template) *(only in global event)*\n  - The meta data\n    - `fragment`: The number of fragment.\n    - `before`: The previous word.\n    - `line`: The whole command line buffer allow you to parse and reply as you wish.\n    - `reply`: This is the reply function to use *this-less* API.\n\n### Global Event\n\nYou also can be able to listen all fragments by \"complete\" event.\n\n```javascript\ncomplete.on('complete', (fragment, { reply }) => reply([\"hello\", \"world\"]));\n```\n\n### Numbered Arguments\n\nYou also can listen events by its order.\n\n```javascript\ncomplete.on('$1', ({ reply }) => reply([\"hello\", \"world\"]))\n```\n\n### Autocompletion Tree\n\nYou can create **completion tree** to more complex autocompletions.\n\n```js\nomelette('hello').tree({\n  how: {\n    much: {\n      is: {\n        this: ['car'],\n        that: ['house'],\n      }\n    }\n    are: ['you'],\n    many: ['cars', 'houses'],\n  },\n  where: {\n    are: {\n      you: ['from'],\n      the: ['houses', 'cars'],\n    },\n    is: {\n      // You can also add some logic with defining functions:\n      your() {\n        return ['house', 'car'];\n      },\n    }\n  },\n}).init()\n```\n\nNow you will be able to use your completion as tree.\n\n<img src=\"https://raw.github.com/f/omelette/master/resources/omelette-tree-new.gif?v1\" width=\"640\">\n\n> Thanks [@jblandry](https://github.com/jblandry) for the idea.\n\n#### Advanced Tree Implementations\n\nYou can seperate your autocompletion by importing objects from another file:\n\n```js\nomelette('hello').tree(require('./autocompletion-tree.js')).init();\n```\n\n### Short Names\n\nYou can set short name of an executable:\n\nIn this example, `githubber` is long and `gh` is shorter examples.\n\n```javascript\nomelette('githubber|gh <module> <command> <suboption>');\n```\n\n## Test\n\nNow, you can try it in your shell.\n\n```bash\ngit clone https://github.com/f/omelette\ncd omelette/example\nalias githubber=\"./githubber\" # The app should be global, completion will search it on global level.\n./githubber --setup --debug # --setup is not provided by omelette, you should proxy it.\n# (reload bash, or source ~/.bash_profile or ~/.config/fish/config.fish)\nomelette-debug-githubber # See Debugging section\ngithubber<tab>\nghb<tab> # short alias\ngh<tab> # short alias\n```\n\n### Debugging\n\n`--debug` option generates a function called `omlette-debug-<programname>`.\n(`omlette-debug-githubber` in this example).\n\nWhen you run `omlette-debug-<programname>`, it will create aliases for your\napplication. (`githubber` and `gh` in this example).\n\nLong name,\n\n```bash\n$ githubber<tab>\nclone update push\n```\n\nOr short name:\n\n```bash\n$ gh<tab>\nclone update push\n```\n\nThen you can start easily.\n\n```bash\n$ ./githubber<tab>\nclone update push\n```\n\n```bash\n$ ./githubber cl<tab>\n$ ./githubber clone<tab>\nGuest fka\n```\n\n```bash\n$ ./githubber clone fka<tab>\n$ ./githubber clone fka http://github.com/fka/<tab>\nhttp://github.com/fka/helloworld\nhttp://github.com/fka/blabla\n```\n\n## Who uses?\n\n**Windows Azure** uses Omelette to support autocompletion in [azure-cli](https://github.com/WindowsAzure/azure-sdk-tools-xplat).\n\n## Contribute\n\nI need your contributions to make that work better!\n\n## License\n\nThis project licensed under MIT.\n",
    "license": "MIT"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmmirror.com/omelette/-/omelette-0.4.5.tgz#f16bc477b7e263b59796a65661964e4762e9ae74",
    "type": "tarball",
    "reference": "https://registry.npmmirror.com/omelette/-/omelette-0.4.5.tgz",
    "hash": "f16bc477b7e263b59796a65661964e4762e9ae74",
    "integrity": "sha512-b0k9uqwF60u15KmVkneVw96VYRtZu2QCbXUQ26SgdyVUgMBzctzIfhNPKAWl4oqJEKpe52CzBYSS+HIKtiK8sw==",
    "registry": "npm",
    "packageName": "omelette",
    "cacheIntegrity": "sha512-b0k9uqwF60u15KmVkneVw96VYRtZu2QCbXUQ26SgdyVUgMBzctzIfhNPKAWl4oqJEKpe52CzBYSS+HIKtiK8sw== sha1-8WvEd7fiY7WXlqZWYZZOR2LprnQ="
  },
  "registry": "npm",
  "hash": "f16bc477b7e263b59796a65661964e4762e9ae74"
}