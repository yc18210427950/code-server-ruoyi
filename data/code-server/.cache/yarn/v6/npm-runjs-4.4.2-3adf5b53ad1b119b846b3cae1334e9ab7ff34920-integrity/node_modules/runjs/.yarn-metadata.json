{
  "manifest": {
    "name": "runjs",
    "version": "4.4.2",
    "description": "Minimalistic building tool",
    "keywords": [
      "build",
      "system",
      "make",
      "tool"
    ],
    "main": "lib/index.js",
    "types": "lib/index.d.ts",
    "bin": {
      "run": "bin/run.js"
    },
    "scripts": {
      "lint": "tslint -c tslint.json 'src/*.ts'",
      "build": "tsc",
      "test": "yarn lint && yarn build && yarn sandbox:dev && jest ./test --coverage",
      "test:unit": "jest ./test/unit/",
      "test:e2e": "jest ./test/e2e/",
      "test:prod": "yarn sandbox:prod && jest ./test/e2e/",
      "sandbox:clean": "rm -rf ./test/e2e/sandbox/node_modules && mkdir -p ./test/e2e/sandbox/node_modules/.bin",
      "sandbox:dev": "yarn sandbox:clean && ln -s ../../../../ ./test/e2e/sandbox/node_modules/runjs",
      "sandbox:prod": "yarn sandbox:clean && (cd ./test/e2e/sandbox && yarn add runjs)",
      "clean": "rm -rf node_modules && yarn sandbox:clean"
    },
    "lint-staged": {
      "src/*.{ts,tsx}": [
        "tslint --fix",
        "git add"
      ]
    },
    "engines": {
      "node": ">=6.11.1"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/pawelgalazka/runjs.git"
    },
    "author": {
      "name": "Pawel Galazka"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/pawelgalazka/runjs/issues"
    },
    "homepage": "https://github.com/pawelgalazka/runjs#readme",
    "dependencies": {
      "chalk": "2.3.0",
      "lodash.padend": "4.6.1",
      "microcli": "1.3.3",
      "omelette": "0.4.5"
    },
    "devDependencies": {
      "@types/jest": "23.3.12",
      "@types/lodash.padend": "4.6.4",
      "@types/node": "10.12.18",
      "husky": "1.3.1",
      "jest": "23.6.0",
      "lint-staged": "8.1.0",
      "prettier": "1.15.3",
      "ts-jest": "23.10.5",
      "tslint": "5.12.1",
      "tslint-config-prettier": "1.17.0",
      "tslint-plugin-prettier": "2.0.1",
      "typescript": "3.2.2"
    },
    "_registry": "npm",
    "_loc": "/config/.cache/yarn/v6/npm-runjs-4.4.2-3adf5b53ad1b119b846b3cae1334e9ab7ff34920-integrity/node_modules/runjs/package.json",
    "readmeFilename": "README.md",
    "readme": "# runjs ![node version](https://img.shields.io/node/v/runjs.svg) [![Build Status](https://travis-ci.org/pawelgalazka/runjs.svg?branch=master)](https://travis-ci.org/pawelgalazka/runjs) [![npm version](https://badge.fury.io/js/runjs.svg)](https://badge.fury.io/js/runjs)\n\nMinimalistic building tool\n\n- [Get started](#get-started)\n- [Why runjs ?](#why-runjs-)\n- [Features](#features)\n    - [Executing shell commands](#executing-shell-commands)\n    - [Handling arguments](#handling-arguments)\n    - [Documenting tasks](#documenting-tasks)\n    - [Namespacing](#namespacing)\n    - [Sharing tasks](#sharing-tasks)\n    - [Autocompletion](#autocompletion)\n- [Transpilers](#transpilers)\n    - [Babel](#babel)\n    - [TypeScript](#typescript)\n- [API](#api)\n    - [run](#runcmd-options)\n    - [options](#optionsthis)\n    - [help](#helpfunc-annotation)\n- [Using Async/Await](#using-asyncawait)\n\n\n> For 3.x to 4.x migration instructions look [here](https://github.com/pawelgalazka/runjs/releases/tag/v4.0.0)\n\n\n## Get started\n\nInstall runjs in your project\n\n    npm install runjs --save-dev\n    \nCreate `runfile.js` in your root project directory:\n\n```js\nconst { run } = require('runjs')\n\nfunction hello(name = 'Mysterious') {\n  console.log(`Hello ${name}!`)\n}\n\nfunction makedir() {\n  run('mkdir somedir')\n}\n\nmodule.exports = {\n  hello,\n  makedir\n}\n```\n\nCall in your terminal:\n\n```bash\n$ npx run hello Tommy\nHello Tommy!\n$ npx run makedir\nmkdir somedir\n```\n\n> For node < 8.2, [npx](https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b)\nis not available, so doing `npm install -g runjs-cli` is neccessary which installs\nglobal `run` script. After that above task would be called like: `run hello Tommy`\n\nMechanism of RunJS is very simple. Tasks are run by just importing `runfile.js` as a\nnormal node.js module. Then based on command line arguments proper exported function\nfrom `runfile.js` is called.\n\nRunJS in a nutshell\n\n```js\nconst runfile = require(path.resolve('./runfile'))\nconst taskName = process.argv[2]\nconst { options, params } = parseArgs(process.argv.slice(2))\n\nrunfile[taskName].apply({ options }, params)\n```\n\n\n## Why runjs ?\n\nWe have Grunt, Gulp, npm scripts, Makefile. Why another building tool ?\n\nGulp or Grunt files seem overly complex for what they do and the plugin\necosystem adds a layer of complexity towards the simple command\nline tools underneath. The documentation is not always up to date\nand the plugin does not always use the latest version of the tool.\nAfter a while customizing the process even with simple things,\nreconfiguring it becomes time consuming.\n\nNpm scripts are simple but they get out of hand pretty quickly if\nwe need more complex process which make them quite hard to read\nand manage.\n\nMakefiles are simple, better for more complex processes\nbut they depend on bash scripting. Within `runfile` you can use\ncommand line calls as well as JavaScript code and npm\nlibraries which makes that approach much more flexible.\n\n[More](https://hackernoon.com/simple-build-tools-npm-scripts-vs-makefile-vs-runjs-31e578278162)\n\n\n## Features\n\n### Executing shell commands\n\nRunJS gives an easy way to execute shell commands in your tasks by `run` function\nin synchronous and asynchronous way:\n\n```js\nconst { run } = require('runjs')\n\nfunction commands () {\n  run('jest')\n  run(`webpack-dev-server --config webpack.config.js`, {\n    async: true\n  })\n}\n\nmodule.exports = {\n  all\n}\n```\n\n```bash\n$ run commands\n```\n\nBecause `./node_modules/.bin` is included in `PATH` when calling shell commands\nby `run` function, you can call \"bins\" from your local project in the same way as \nin npm scripts.\n\n### Handling arguments\n\nProvided arguments in the command line are passed to the function:\n\n\n```javascript\nfunction sayHello (who) {\n  console.log(`Hello ${who}!`)\n}\n\nmodule.exports = {\n  sayHello\n}\n```\n\n```bash\n$ run sayHello world\nHello world!\n```\n    \nYou can also provide dash arguments like `-a` or `--test`. Order of them doesn't \nmatter after task name. They will be always available by `options` helper \nfrom inside a function.\n\n```javascript\nconst { options } = require('runjs')\n\nfunction sayHello (who) {\n  console.log(`Hello ${who}!`)\n  console.log('Given options:', options(this))\n}\n\nmodule.exports = {\n  sayHello\n}\n```\n\n```bash\n$ run sayHello -a --test=something world\nHello world!\nGiven options: { a: true, test: 'something' }\n```\n    \n    \n### Documenting tasks\n\nTo display all available tasks for your `runfile.js` type `run` in your command line\nwithout any arguments:\n\n    $ run\n    Processing runfile.js...\n    \n    Available tasks:\n    echo                    - echo task description\n    buildjs                 - Compile JS files\n    \nUse `help` utility function for your task to get additional description:\n\n```javascript\nconst { run, help } = require('runjs')\n\nfunction buildjs () {\n  \n}\n\nhelp(buildjs, 'Compile JS files')\n\nmodule.exports = {\n  buildjs\n}\n```\n\n    $ run buildjs --help\n    Processing runfile.js...\n    \n    Usage: buildjs\n    \n    Compile JS files\n    \nYou can provide detailed annotation to give even more info about the task:\n\n```javascript\nconst dedent = require('dedent')\nconst { run, help } = require('runjs')\n\nfunction test (file) {\n  \n}\n\nhelp(test, {\n  description: 'Run unit tests',\n  params: ['file'],\n  options: {\n    watch: 'run tests in a watch mode'\n  },\n  examples: dedent`\n    run test dummyComponent.js\n    run test dummyComponent.js --watch\n  `\n})\n\nmodule.exports = {\n  test\n}\n```\n\n    $ run test --help\n    Processing runfile.js...\n    \n    Usage: test [options] [file]\n    \n    Run unit tests\n    \n    Options:\n    \n      --watch       run tests in a watch mode\n      \n    Examples:\n    \n    run test dummyComponent.js\n    run test dummyComponent.js --watch\n\n\n### Namespacing\n\nTo better organise tasks, it is possible to call them from namespaces:\n```js\nconst test = {\n  unit () {\n    console.log('Doing unit testing!')\n  }\n}\n\nmodule.exports = {\n  test\n}\n```\n\n```bash\n$ run test:unit\nDoing unit testing!\n```\n\nThis is especially useful if `runfile.js` gets too large. We can move some tasks\nto external modules and import them back to a namespace:\n\n`./tasks/test.js`:\n\n```javascript\nfunction unit () {\n  console.log('Doing unit testing!')\n}\n\nfunction integration () {\n  console.log('Doing unit testing!')\n}\n\nmodule.exports = {\n  unit,\n  integration\n}\n```\n\n`runfile.js`\n```js\nconst test = require('./tasks/test')\n\nmodule.exports = {\n  test\n}\n```\n\n```bash\n$ run test:unit\nDoing unit testing!\n```\n\nIf we don't want to put imported tasks into a namespace, we can always use spread\noperator:\n\n```js\nmodule.exports = {\n  ...test\n}\n```\n\n```bash\n$ run unit\nDoing unit testing!\n```\n\nWith ES6 modules import/export syntax this becomes even simpler:\n\n```js\n// export with no namespace\nexport * from './tasks/test' // no namespace\n\n// export with namespace\nimport * as test from './tasks/test'\nexport { test } // add namespace\n```\n\n```bash\n$ run unit\n$ run test:unit\n```\n\n### Sharing tasks\n\nBecause `runfile.js` is just a node.js module and `runjs` just calls exported\nfunctions from that module based on cli arguments, nothing stops you to move \nsome repetitive tasks across your projects to external npm package and \njust reuse it.\n\n`shared-runfile` module:\n```js\nfunction shared1 () {\n  console.log('This task is shared!')\n}\n\nfunction shared2 () {\n  console.log('This task is shared!')\n}\n\nmodule.exports = {\n  shared1,\n  shared2\n}\n```\n\nLocal `runfile.js`\n```js\nconst shared = require('shared-runfile')\n\nfunction local () {\n  console.log('This task is local!')\n}\n\nmodule.exports = {\n  ...shared,\n  local\n}\n```\n\n```bash\n$ run shared1\n$ run shared2\n$ run local\n```\n\n### Autocompletion\n\nAfter setting up autocompletion, suggestions about available\ntasks from your `runfile.js` will be given when calling `run <tab>`.\n\n> This is an experimental feature. It will work slowly if you\nuse transpiler with your `runfile.js`. It won't work also\nwith `npx run <task>` calls, `npm -g install runjs-cli` is necessary,\nso you could do calls like `run <task>`.\n\nSetup process:\n\n1. `run --completion >> ~/runjs.completion.sh`\n2. `echo 'source ~/runjs.completion.sh' >> .bash_profile`\n3. Restart your shell (reopen terminal)\n\n> Depending on your shell, use proper bootstrap files accordingly.\n\n> If you get errors like `_get_comp_words_by_ref command not found`\nyou need to install [bash completion](https://github.com/scop/bash-completion)\npackage. For MacOS users doing `brew install bash-completion` should\ndo the job and then adding `[ -f /usr/local/etc/bash_completion ] && ./usr/local/etc/bash_completion`.\nto your `~/.bash_profile`.\n\n\n## Transpilers\n\nTranspilers gives you an advantage of using ES6/ES7 features which may not be \navailable in your node version.\n\nSo for example writing `runfile.js` with es6 imports/exports is possible:\n\n```js\nimport { run } from 'runjs'\n\nexport function makeThatDir(name) {\n  run(`mkdir ${name}`)\n  console.log('Done!')\n}\n```\n\n```bash\n$ run makeThatDir somedir\nmkdir somedir\nDone!\n```\n\n#### Babel\n\nIf you want to use Babel transpiler for your `runfile.js` install it:\n\n    npm install babel-core babel-preset-es2015 babel-register --save-dev\n\nand in your `package.json` write:\n\n```json\n{\n  \"babel\": {\n    \"presets\": [\"es2015\"]\n  },\n  \"runjs\": {\n    \"requires\": [\n      \"./node_modules/babel-register\"\n    ]\n  }\n}\n\n```\n\nRunJS will require defined transpiler before requiring `runfile.js` so you can\nuse all ES6/ES7 features which are not supported by your node version. \n\n    \n#### TypeScript\n\nIf you want to use TypeScript transpiler for your runfile, install TypeScript \ntooling:\n\n    npm install typescript ts-node --save-dev\n\nand then in your `package.json` define a path to `ts-node/register` and \n`runfile.ts`.\n\n```json\n{\n  \"runjs\": {\n    \"requires\": [\n      \"./node_modules/ts-node/register\"\n    ],\n    \"runfile\": \"./runfile.ts\"\n  }\n}\n```\n\nYou need to also define custom path to your runfile as TypeScript files have\n`*.ts` extension. RunJS will require defined transpiler before requiring \n`./runfile.ts`.\n\n\n## API\n\nFor inside `runfile.js` usage.\n\n#### run(cmd, options)\n\nrun given command as a child process and log the call in the output. \n`./node_modules/.bin/` is included into PATH so you can call installed scripts directly.\n\n```js\nconst { run } = require('runjs')\n```\n\n*Options:*\n\n```javascript\n{\n    cwd: ..., // current working directory (String)\n    async: ... // run command asynchronously (true/false), false by default\n    stdio: ... // 'inherit' (default), 'pipe' or 'ignore'\n    env: ... // environment key-value pairs (Object)\n    timeout: ...\n}\n```\n\n*Examples:*\n\nTo get an output from `run` function we need to set `stdio` option to `pipe` otherwise\n`output` will be `null`:\n\n```javascript\nconst output = run('ls -la', {stdio: 'pipe'})\nrun('http-server .', {async: true, stdio: 'pipe'}).then((output) => {\n  log(output) \n}).catch((error) => {\n  throw error\n})\n```\n\nFor `stdio: 'pipe'` outputs are returned but not forwarded to the parent process thus \nnot printed out to the terminal. \n\nFor `stdio: 'inherit'` (default) outputs are passed \nto the terminal, but `run` function will resolve (async) / return (sync)\n`null`.\n\nFor `stdio: 'ignore'` nothing will be returned or printed\n\n\n#### options(this)\n\nA helper which returns an object with options which were given through dash \nparams of command line script.\n\n```js\nconst { options } = require('runjs')\n```\n\nExample:\n\n```bash\n$ run lint --fix\n```\n\n```js\nfunction lint (path = '.') {\n  options(this).fix ? run(`eslint ${path} --fix`) : run(`eslint ${path}`) \n}\n```\n\nTo execute a task in JS with options:\n\n```js\nlint.call({ options: { fix: true }}, './component.js')\n```\n\n\n#### help(func, annotation)\n\nDefine help annotation for task function, so it will be printed out when calling task with `--help`\noption and when calling `run` without any arguments.\n\n```js\nconst { help } = require('runjs')\n```\n\n\n```javascript\nhelp(build, 'Generate JS bundle')\n\nhelp(test, {\n  description: 'Run unit tests',\n  params: ['file'],\n  options: {\n    watch: 'run tests in a watch mode'\n  },\n  examples: `\n    run test dummyComponent.js\n    run test dummyComponent.js --watch\n  `\n})\n```\n\n    $ run build --help\n    $ run test --help\n\n\n## Using Async/Await\n\nFor node >= 7.10 it is possible to use async functions out of the box since node \nwill support them natively.\n\nExpected usage in your runfile:\n\n```javascript\nconst { run } = require('runjs')\n\nasync function testasyncawait () {\n  await run('ls -al | cat', {async: true}).then((data) => {\n    console.log('DATA', data)\n  })\n  console.log('After AWAIT message')\n}\n\nmodule.exports = {\n  testasyncawait\n}\n```\n\nand then just\n\n```\n$ run testasyncawait\n```\n\nIf your node version is older you need to depend on transpilers, \neither `Babel` or `TypeScript`. For `TypeScript` you do no more than transpiler\nsetup which was described [above](#typescript) and async/await should just\nwork.\n\nFor `Babel` you additionally need `babel-preset-es2017` and `babel-polyfill`:\n\n    npm install babel-preset-es2017 babel-polyfill --save-dev\n    \nand proper config in your `package.json`:\n\n    \"babel\": {\n      \"presets\": [\"es2017\"]\n    },\n    \"runjs\": {\n      \"requires\": [\n        \"./node_modules/babel-polyfill\",\n        \"./node_modules/babel-register\"\n      ]\n    }\n\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2015 Paweł Gałązka\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmmirror.com/runjs/-/runjs-4.4.2.tgz#3adf5b53ad1b119b846b3cae1334e9ab7ff34920",
    "type": "tarball",
    "reference": "https://registry.npmmirror.com/runjs/-/runjs-4.4.2.tgz",
    "hash": "3adf5b53ad1b119b846b3cae1334e9ab7ff34920",
    "integrity": "sha512-/DB54HRJnxfGA/a9QLZMyAn8H84SMt8oVGF7Vz+OS4BMCve312DXNRpy6Z8yohLuoMctoalXQtvmpd2ChQYD4Q==",
    "registry": "npm",
    "packageName": "runjs",
    "cacheIntegrity": "sha512-/DB54HRJnxfGA/a9QLZMyAn8H84SMt8oVGF7Vz+OS4BMCve312DXNRpy6Z8yohLuoMctoalXQtvmpd2ChQYD4Q== sha1-Ot9bU60bEZuEazyuEzTpq3/zSSA="
  },
  "registry": "npm",
  "hash": "3adf5b53ad1b119b846b3cae1334e9ab7ff34920"
}